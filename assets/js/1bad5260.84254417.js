"use strict";(self.webpackChunkswarmcloud_docs=self.webpackChunkswarmcloud_docs||[]).push([[3926],{5680:(e,n,t)=>{t.d(n,{xA:()=>g,yg:()=>y});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach(function(n){a(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},g=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef(function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),d=p(t),c=a,y=d["".concat(s,".").concat(c)]||d[c]||u[c]||i;return t?r.createElement(y,l(l({ref:n},g),{},{components:t})):r.createElement(y,l({ref:n},g))});function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:a,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9453:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>g,contentTitle:()=>s,default:()=>f,frontMatter:()=>o,metadata:()=>p,toc:()=>d});t(6540);var r=t(5680);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,r)}return t}(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}),e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}const o={title:"API & Config",sidebar_position:3},s=void 0,p={unversionedId:"API",id:"API",title:"API & Config",description:"P2P Configuration",source:"@site/docs/android/API.mdx",sourceDirName:".",slug:"/API",permalink:"/home/android/API",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"API & Config",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Usage",permalink:"/home/android/"}},g={},d=[{value:"P2P Configuration",id:"p2p-configuration",level:2},{value:"P2pEngine",id:"p2pengine",level:2},{value:"Switch Stream URL",id:"switch-stream-url",level:3},{value:"P2pEngine API",id:"p2pengine-api",level:3},{value:"<strong><em>P2pEngine.version</em></strong>",id:"p2pengineversion",level:4},{value:"<strong><em>P2pEngine.instance</em></strong>",id:"p2pengineinstance",level:4},{value:"<strong><em>engine.parseStreamUrl(url: String)</em></strong>",id:"engineparsestreamurlurl-string",level:4},{value:"<strong><em>engine.parseStreamUrl(url: String, videoId: String)</em></strong>",id:"engineparsestreamurlurl-string-videoid-string",level:4},{value:"<strong><em>engine.parseStreamUrl(url: String, videoId: String, mimeType: MimeType)</em></strong>",id:"engineparsestreamurlurl-string-videoid-string-mimetype-mimetype",level:4},{value:"<strong><em>engine.isConnected</em></strong>",id:"engineisconnected",level:4},{value:"<strong><em>engine.stopP2p()</em></strong>",id:"enginestopp2p",level:4},{value:"<strong><em>engine.restartP2p()</em></strong>",id:"enginerestartp2p",level:4},{value:"<strong><em>engine.peerId</em></strong>",id:"enginepeerid",level:4},{value:"<strong><em>engine.setHttpHeadersForHls(headers: Map&lt;String, String&gt;?)</em></strong>",id:"enginesethttpheadersforhlsheaders-mapstring-string",level:4},{value:"<strong><em>engine.setHttpHeadersForDash(headers: Map&lt;String, String&gt;?)</em></strong>",id:"enginesethttpheadersfordashheaders-mapstring-string",level:4},{value:"<strong><em>engine.notifyPlaybackStalled()</em></strong>",id:"enginenotifyplaybackstalled",level:4},{value:"<strong><em>engine.disableP2p()</em></strong>",id:"enginedisablep2p",level:3},{value:"<strong><em>engine.enableP2p()</em></strong>",id:"engineenablep2p",level:3},{value:"<strong><em>engine.shutdown()</em></strong>",id:"engineshutdown",level:4},{value:"P2P Statistics",id:"p2p-statistics",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Callback Player Stats",id:"callback-player-stats",level:3},{value:"Dynamic Url Support",id:"dynamic-url-support",level:3},{value:"StrictSegmentId Mode",id:"strictsegmentid-mode",level:3},{value:"Setup HTTP headers",id:"setup-http-headers",level:3},{value:"Specify the Preferred Point in the Video to Start Playback.",id:"specify-the-preferred-point-in-the-video-to-start-playback",level:3},{value:"Report Player Rebuffering",id:"report-player-rebuffering",level:3},{value:"Intercept m3u8/mpd",id:"intercept-m3u8mpd",level:3},{value:"Support Media Files without Suffixes",id:"support-media-files-without-suffixes",level:3},{value:"Pass your Customized OkHttpClient",id:"pass-your-customized-okhttpclient",level:3},{value:"Bypass User-specific Segments",id:"bypass-user-specific-segments",level:3},{value:"Listen to SDK Exception",id:"listen-to-sdk-exception",level:3}],u=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",n)},c=u("Tabs"),y=u("TabItem"),m={toc:d},h="wrapper";function f(e){var{components:n}=e,t=l(e,["components"]);return(0,r.yg)(h,i(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){a(e,n,t[n])})}return e}({},m,t),{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"p2p-configuration"},"P2P Configuration"),(0,r.yg)("p",null,"A ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"P2pConfig"))," can be obtained via its builder, the parameters below is the default values:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},'val config = P2pConfig.Builder()\n.logEnabled(false)                                  // Enable or disable log\n.logLevel(LogLevel.WARN)                            // Print log level\n.trackerZone(TrackerZone.Europe)                    // The country enum for the tracker server address(Europe, HongKong, USA).\n.downloadTimeout(30_000, TimeUnit.MILLISECONDS)     // TS file download timeout by HTTP\n.localPortHls(0)                                    // The port for local http server of HLS(Use random port by default)\n.localPortDash(0)                                   // The port for local http server of DASH(Use random port by default)\n.diskCacheLimit(2000*1024*1024)                     // The max size of binary data that can be stored in the disk cache for VOD(Set to 0 will disable disk cache)\n.memoryCacheCountLimit(15)                          // The max count of ts files that can be stored in the memory cache\n.p2pEnabled(true)                                   // Enable or disable p2p engine\n.withTag(null)                                      // Add a custom label to every different user session, which in turn will provide you the ability to have more meaningful analysis of the data gathered\n.webRTCConfig(null)                                 // Providing options to configure WebRTC connections\n.maxPeerConnections(25)                             // Max peer connections at the same time\n.startFromSegmentOffset(3)                          // The segment offset that start to connect to tracker server\n.useHttpRange(true)                                 // Use HTTP ranges requests where it is possible. Allows to continue (and not start over) aborted P2P downloads over HTTP\n.useStrictHlsSegmentId(false)                       // Use segment url based segment id instead of sequence number based one\n.httpHeadersForHls(null)                            // Set HTTP Headers while requesting ts and m3u8.\n.httpHeadersForDash(null)                           // Set HTTP Headers while requesting Dash files.\n.sharePlaylist(false)                               // Allow the P2P transmission of m3u8 file.\n.prefetchOnly(false)                                // Only use prefetch strategy in p2p downloading(Only for HLS).\n.logPersistent(false)                               // Save logs to the file({Environment.getExternalStorageDirectory()}/logger/).\n.insertTimeOffsetTag(null)                          // Insert "#ext-x-start: time-offset = [timeOffset]" in m3u8 file to force the player to start loading from the first ts of playlist, where [timeOffset] is the offset in seconds to start playing the video, only works on live mode\n.p2pProtocolVersion(P2pProtocolVersion.V8)          // The version of P2P protocol, only have the same protocol version as another platform can both interconnect with each other\n.dashMediaFiles(\n    arrayListOf("mp4", "fmp4", "webm", "m4s", "m4v"))       // The supported media file type of DASH.\n.build()\n')),(0,r.yg)("h2",{id:"p2pengine"},"P2pEngine"),(0,r.yg)("p",null,"Instantiate ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"P2pEngine")),", which is a singleton\uff1a"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"P2pEngine.init(context, token, config)\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pEngine.init(context, token, config);\n")))),(0,r.yg)("p",null,"Explanation:"),(0,r.yg)("br",null),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"center"},"param"),(0,r.yg)("th",{parentName:"tr",align:"center"},"type"),(0,r.yg)("th",{parentName:"tr",align:"center"},"required"),(0,r.yg)("th",{parentName:"tr",align:"center"},"description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("strong",{parentName:"td"},(0,r.yg)("em",{parentName:"strong"},"context"))),(0,r.yg)("td",{parentName:"tr",align:"center"},"Context"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Yes"),(0,r.yg)("td",{parentName:"tr",align:"center"},"The instance of Application Context is recommended.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("strong",{parentName:"td"},(0,r.yg)("em",{parentName:"strong"},"token"))),(0,r.yg)("td",{parentName:"tr",align:"center"},"String"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Yes"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Token assigned by CDNBye.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("strong",{parentName:"td"},(0,r.yg)("em",{parentName:"strong"},"config"))),(0,r.yg)("td",{parentName:"tr",align:"center"},"P2pConfig"),(0,r.yg)("td",{parentName:"tr",align:"center"},"No"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Custom configuration.")))),(0,r.yg)("h3",{id:"switch-stream-url"},"Switch Stream URL"),(0,r.yg)("p",null,"When Switching to a new stream URL, before passing new stream url to the player, pass that URL through ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"P2pEngine"))," instance:"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"val parsedUrl = P2pEngine.instance.parseStreamUrl(url)\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"String parsedUrl = P2pEngine.getInstance().parseStreamUrl(url);\n")))),(0,r.yg)("h3",{id:"p2pengine-api"},"P2pEngine API"),(0,r.yg)("h4",{id:"p2pengineversion"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"P2pEngine.version"))),(0,r.yg)("p",null,"Current SDK version."),(0,r.yg)("h4",{id:"p2pengineinstance"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"P2pEngine.instance"))),(0,r.yg)("p",null,"Get the singleton of ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"P2pEngine")),"."),(0,r.yg)("h4",{id:"engineparsestreamurlurl-string"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.parseStreamUrl(url: String)"))),(0,r.yg)("p",null,"Convert original playback address (m3u8/mpd) to the address of the local proxy server."),(0,r.yg)("h4",{id:"engineparsestreamurlurl-string-videoid-string"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.parseStreamUrl(url: String, videoId: String)"))),(0,r.yg)("p",null,"Pass video ID for making channel ID in addition to original playback address."),(0,r.yg)("h4",{id:"engineparsestreamurlurl-string-videoid-string-mimetype-mimetype"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.parseStreamUrl(url: String, videoId: String, mimeType: MimeType)"))),(0,r.yg)("p",null,"If your URI doesn\u2019t end with .m3u8/.mpd, you can pass MimeType.APPLICATION_M3U8 or MimeType.APPLICATION_MPD to the third parameter of parseStreamUrl to explicitly indicate the type of the content."),(0,r.yg)("h4",{id:"engineisconnected"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.isConnected"))),(0,r.yg)("p",null,"Check if connected with CDNBye backend."),(0,r.yg)("h4",{id:"enginestopp2p"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.stopP2p()"))),(0,r.yg)("p",null,"Once the video is done playing, you have to stop the P2P streaming you created earlier. Calling this method will finish the ongoing tasks and release the resources."),(0,r.yg)("h4",{id:"enginerestartp2p"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.restartP2p()"))),(0,r.yg)("p",null,"Resume P2P if it has been stopped."),(0,r.yg)("h4",{id:"enginepeerid"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.peerId"))),(0,r.yg)("p",null,"Get the peer ID of this engine."),(0,r.yg)("h4",{id:"enginesethttpheadersforhlsheaders-mapstring-string"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.setHttpHeadersForHls(headers: Map<String, String>?)"))),(0,r.yg)("p",null,"Set HTTP Headers while requesting ts and m3u8 dynamically."),(0,r.yg)("h4",{id:"enginesethttpheadersfordashheaders-mapstring-string"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.setHttpHeadersForDash(headers: Map<String, String>?)"))),(0,r.yg)("p",null,"Set HTTP Headers while requesting Dash files dynamically."),(0,r.yg)("h4",{id:"enginenotifyplaybackstalled"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.notifyPlaybackStalled()"))),(0,r.yg)("p",null,"Notify SDK the player stalled."),(0,r.yg)("h3",{id:"enginedisablep2p"},(0,r.yg)("strong",{parentName:"h3"},(0,r.yg)("em",{parentName:"strong"},"engine.disableP2p()"))),(0,r.yg)("p",null,"P2P will be disabled dynamically at runtime, it will not take effect until the next media file is played."),(0,r.yg)("h3",{id:"engineenablep2p"},(0,r.yg)("strong",{parentName:"h3"},(0,r.yg)("em",{parentName:"strong"},"engine.enableP2p()"))),(0,r.yg)("p",null,"P2P will be enabled dynamically at runtime, it will not take effect until the next media file is played."),(0,r.yg)("h4",{id:"engineshutdown"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.shutdown()"))),(0,r.yg)("p",null,"Stop P2P and shut down the proxy server."),(0,r.yg)("h3",{id:"p2p-statistics"},"P2P Statistics"),(0,r.yg)("p",null,"Add an observer ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"P2pStatisticsListener"))," to observe downloading statistics:"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"engine.addP2pStatisticsListener(object : P2pStatisticsListener {\n    override fun onHttpDownloaded(value: Int) {\n    }\n\n    override fun onP2pDownloaded(value: Int, speed: Int) {\n    }\n\n    override fun onP2pUploaded(value: Int, speed: Int) {\n    }\n\n    override fun onPeers(peers: List<String>) {\n    }\n\n    override fun onServerConnected(connected: Boolean) {\n    }\n})\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"engine.addP2pStatisticsListener(new P2pStatisticsListener() {\n    @Override\n    public void onHttpDownloaded(int value) {\n    }\n\n    @Override\n    public void onP2pDownloaded(int value, int speed) {\n    }\n\n    @Override\n    public void onP2pUploaded(int value, int speed) {\n    }\n\n    @Override\n    public void onPeers(@NonNull List<String> peers) {\n    }\n\n    @Override\n    public void onServerConnected(boolean connected) {\n    }\n});\n")))),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"The unit of download and upload is KB.\nThe unit of download speed is KB/s.")),(0,r.yg)("h2",{id:"advanced-usage"},"Advanced Usage"),(0,r.yg)("h3",{id:"callback-player-stats"},"Callback Player Stats"),(0,r.yg)("p",null,"On Live streaming, to improve performance, we recommend telling p2p engine the duration from the playback time to the end of the buffered interval.\nIn order to do so, you need to use callback ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"setPlayerInteractor"))," ."),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"P2pEngine.instance?.setPlayerInteractor(object : PlayerInteractor() {\n    override fun onBufferedDuration(): Long {\n        return if (player != null) {\n            // Exoplayer in milliseconds\n            player!!.bufferedPosition - player!!.currentPosition\n        } else {\n            -1\n        }\n    }\n})\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pEngine.getInstance().setPlayerInteractor(new PlayerInteractor() {\n    public long onBufferedDuration() {\n        // Exoplayer in milliseconds\n        if (play != null) {\n            return player.getBufferedPosition() - player.getCurrentPosition();\n        }\n        return -1;\n    }\n});\n")))),(0,r.yg)("p",null,"On the VOD mode, the duration of a video may be large. If we can match peers with similar playback time, it will help to improve the P2P performance, so we recommend to tell p2p engine the current playback time of player:"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"P2pEngine.instance?.setPlayerInteractor(object : PlayerInteractor() {\n    override fun onCurrentPosition(): Long {\n        // Exoplayer in milliseconds\n        return player?.currentPosition ?: -1\n    }\n})\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pEngine.getInstance().setPlayerInteractor(new PlayerInteractor() {\n    public long onCurrentPosition() {\n        // Exoplayer in milliseconds\n        if (play != null) {\n            return player.getCurrentPosition();\n        }\n        return -1;\n    }\n});\n")))),(0,r.yg)("h3",{id:"dynamic-url-support"},"Dynamic Url Support"),(0,r.yg)("p",null,"The channelId is an identifier used by our backend to match peers that are watching the same content. It is an optional parameter, and by default, we generate videoId from the content URL by removing any query parameters and protocol from it.\nHowever, if specific urls are generated for every viewer (it may be the case if a token is used in the path of the url for security reasons), then the players will think they are not watching the same content, preventing the p2p plugin from being efficient. In this situation, videoIDs are needed."),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"val videoId = extractVideoIdFromUrl(urlString)    // extractVideoIdFromUrl is a function defined by yourself, you just need to extract video id from url\nval parsedUrl = P2pEngine.instance?.parseStreamUrl(urlString, videoId)\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"String videoId = extractVideoIdFromUrl(urlString);  // extractVideoIdFromUrl is a function defined by yourself, you just need to extract video id from url\nString parsedUrl = P2pEngine.getInstance().parseStreamUrl(urlString, videoId);\n")))),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"Interconnect with other platform should ensure that both have the same token and channelId.")),(0,r.yg)("h3",{id:"strictsegmentid-mode"},"StrictSegmentId Mode"),(0,r.yg)("p",null,"You can use segment url based segment id instead of sequence number based one:"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"P2pEngine.instance?.setHlsSegmentIdGenerator(StrictHlsSegmentIdGenerator())\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pEngine.getInstance().setHlsSegmentIdGenerator(new StrictHlsSegmentIdGenerator());\n")))),(0,r.yg)("h3",{id:"setup-http-headers"},"Setup HTTP headers"),(0,r.yg)("p",null,"Some HTTP requests need to add header information such as ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"User-Agent"))," for Anti-Leech or statistical requirements. It can be set via ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"setHttpHeaders"))," :"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},'val headers = mapOf("User-Agent" to "XXX")\nP2pEngine.instance?.setHttpHeadersForHls(headers)\nP2pEngine.instance?.setHttpHeadersForDash(headers)\n'))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'Map headers = new HashMap();\nheaders.put("User-Agent", "XXX");\nengine.setHttpHeadersForHls(headers);\nengine.setHttpHeadersForDash(headers);\n')))),(0,r.yg)("h3",{id:"specify-the-preferred-point-in-the-video-to-start-playback"},"Specify the Preferred Point in the Video to Start Playback."),(0,r.yg)("p",null,"The SDK can insert the ",(0,r.yg)("a",{parentName:"p",href:"https://hlsbook.net/how-to-start-playing-a-video-at-a-specific-point-in-time/"},"EXT-X-START tag")," to start playing a live stream from the start point in time of playlist, however, it may bring more delay to the stream:"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"val config = P2pConfig.Builder()\n        .insertTimeOffsetTag(0.0)\n        .build()\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pConfig config = new P2pConfig.Builder()\n        .insertTimeOffsetTag(0.0)\n        .build();\n")))),(0,r.yg)("h3",{id:"report-player-rebuffering"},"Report Player Rebuffering"),(0,r.yg)("p",null,"You may want to report the player rebuffering event to the sdk, then get average rebuffer ratio from SwarmCloud dashboard:"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"// Take exoplayer as example\nplayer?.addListener(object : Player.Listener {\n    var isDetecting = false\n    override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\n        if (playbackState == 2) {     // STATE_BUFFERING\n            if (isDetecting) return\n            isDetecting = true\n            Timer().schedule(object : TimerTask() {\n                override fun run() {\n                    runOnUiThread {\n                        isDetecting = false\n                        if (!player!!.isPlaying) {\n                            P2pEngine.instance!!.notifyPlaybackStalled()\n                        }\n                    }\n                }\n            }, 8000)\n        }\n    }\n})\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"// Take exoplayer as example\nplayer.addListener(new Player.Listener() {\n    Boolean isDetecting = false;\n    @Override\n    public void onPlaybackStateChanged(int playbackState) {\n        if (playbackState == 2) {       // STATE_BUFFERING\n            if (isDetecting) return;\n            isDetecting = true;\n            new Timer().schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            isDetecting = false;\n                            if (!player.isPlaying()) {\n                                P2pEngine.getInstance().notifyPlaybackStalled();\n                            }\n                        }\n                    });\n                }\n            }, 8000);\n        }\n    }\n});\n")))),(0,r.yg)("h3",{id:"intercept-m3u8mpd"},"Intercept m3u8/mpd"),(0,r.yg)("p",null,"The SDK will parse the contents of m3u8/mpd when downloaded, if you use encrypted m3u8/mpd, you need to use the interceptor to intercept and return the standard m3u8/mpd file:"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"P2pEngine.instance?.setHlsInterceptor(object : HlsInterceptor() {\n    override fun interceptPlaylist(text: ByteArray, url: String): ByteArray {\n        return handlePlaylist(text, url);\n    }\n})\nP2pEngine.instance?.setDashInterceptor(object : DashInterceptor() {\n    override fun interceptPlaylist(text: ByteArray, url: String): ByteArray {\n        return handlePlaylist(text, url)\n    }\n})\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pEngine.getInstance().setHlsInterceptor(new HlsInterceptor() {\n    @Override\n    public byte[] interceptPlaylist(byte[] text, String url) {\n        return handlePlaylist(text, url);\n    }\n});\nP2pEngine.getInstance().setDashInterceptor(new DashInterceptor() {\n    @Override\n    public byte[] interceptPlaylist(byte[] text, String url) {\n        return handlePlaylist(text, url);\n    }\n});\n")))),(0,r.yg)("h3",{id:"support-media-files-without-suffixes"},"Support Media Files without Suffixes"),(0,r.yg)("p",null,'Some special files do not end with ".ts" or any other suffixes. You can use the hook function to determine whether they are media files:'),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"P2pEngine.instance?.setHlsInterceptor(object : HlsInterceptor() {\n    override fun isMediaSegment(url: String): Boolean {\n        return true\n    }\n})\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pEngine.getInstance().setHlsInterceptor(new HlsInterceptor() {\n    @Override\n    public boolean isMediaSegment(@NonNull String url) {\n        return true;\n    }\n});\n")))),(0,r.yg)("h3",{id:"pass-your-customized-okhttpclient"},"Pass your Customized OkHttpClient"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"val httpClient = OkHttpClient.Builder()\n    .addInterceptor(YourInterceptor())\n    .build()\nval config = P2pConfig.Builder().okHttpClient(httpClient).build()\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"OkHttpClient httpClient = new OkHttpClient.Builder()\n                .addInterceptor(new YourInterceptor())\n                .build();\nP2pConfig config = new P2pConfig.Builder()\n        .okHttpClient(httpClient)\n        .build();\n")))),(0,r.yg)("h3",{id:"bypass-user-specific-segments"},"Bypass User-specific Segments"),(0,r.yg)("p",null,"Sometimes we don't want some ts files to be shared, such as user-specific ts generated by SSAI (Server Side Ad Insertion). At this time, we can use the segmentBypass function to bypass it:"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"P2pEngine.instance?.setHlsInterceptor(object : HlsInterceptor() {\n    override fun shouldBypassSegment(url: String): Boolean {\n        return isSSAISegment(url)\n    }\n})\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pEngine.getInstance().setHlsInterceptor(new HlsInterceptor() {\n    @Override\n    public boolean shouldBypassSegment(@NonNull String url) {\n        return isSSAISegment(url);\n    }\n});\n")))),(0,r.yg)("h3",{id:"listen-to-sdk-exception"},"Listen to SDK Exception"),(0,r.yg)("p",null,"Due to network, server, algorithm bugs and other reasons, the SDK may have exceptions. You can listen to the exceptions by using the ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"registerExceptionListener"))," :"),(0,r.yg)(c,{groupId:"android",mdxType:"Tabs"},(0,r.yg)(y,{value:"kotlin",label:"kotlin",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-kotlin"},"P2pEngine.instance?.registerExceptionListener(object : EngineExceptionListener {\n    override fun onTrackerException(e: EngineException) {\n        // Tracker Exception\n    }\n    override fun onSignalException(e: EngineException) {\n        // Signal Server Exception\n    }\n    override fun onSchedulerException(e: EngineException) {\n        // Scheduler Exception\n    }\n    override fun onOtherException(e: EngineException) {\n        // Other Exception\n    }\n})\n"))),(0,r.yg)(y,{value:"java",label:"java",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"P2pEngine.getInstance().registerExceptionListener(new EngineExceptionListener() {\n    @Override\n    public void onTrackerException(EngineException e) {\n        // Tracker Exception\n    }\n\n    @Override\n    public void onSignalException(EngineException e) {\n        // Signal Server Exception\n    }\n\n    @Override\n    public void onSchedulerException(EngineException e) {\n        // Scheduler Exception\n    }\n\n    @Override\n    public void onOtherException(EngineException e) {\n        // Other Exception\n    }\n});\n")))))}f.isMDXComponent=!0}}]);