"use strict";(self.webpackChunkswarmcloud_docs=self.webpackChunkswarmcloud_docs||[]).push([[8974],{2867:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>g,default:()=>y,frontMatter:()=>s,metadata:()=>p,toc:()=>d});t(6540);var r=t(5680);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,r)}return t}(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}),e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}const s={title:"API & Config",sidebar_position:3},g=void 0,p={unversionedId:"API",id:"API",title:"API & Config",description:"Create instance",source:"@site/docs/dashjs/API.mdx",sourceDirName:".",slug:"/API",permalink:"/home/dashjs/API",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"API & Config",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Usage",permalink:"/home/dashjs/"}},l={},d=[{value:"Create instance",id:"create-instance",level:2},{value:"var engine = new P2PEngineDash(player, {p2pConfig: opts});",id:"var-engine--new-p2penginedashplayer-p2pconfig-opts",level:3},{value:"P2PEngineDash API",id:"p2penginedash-api",level:2},{value:"<strong><em>P2PEngineDash.version</em></strong> (static)",id:"p2penginedashversion-static",level:4},{value:"<strong><em>P2PEngineDash.protocolVersion</em></strong> (static)",id:"p2penginedashprotocolversion-static",level:4},{value:"<strong><em>P2PEngineDash.isSupported()</em></strong> (static method)",id:"p2penginedashissupported-static-method",level:4},{value:"<strong><em>engine.enableP2P()</em></strong>",id:"engineenablep2p",level:4},{value:"<strong><em>engine.disableP2P()</em></strong>",id:"enginedisablep2p",level:4},{value:"<strong><em>engine.destroy()</em></strong>",id:"enginedestroy",level:4},{value:"P2PEngineDash Events",id:"p2penginedash-events",level:2},{value:"<strong><em>engine.on(&#39;peerId&#39;, function (peerId) {})</em></strong>",id:"engineonpeerid-function-peerid-",level:4},{value:"<strong><em>engine.on(&#39;peers&#39;, function (peers) {})</em></strong>",id:"engineonpeers-function-peers-",level:4},{value:"<strong><em>engine.on(&#39;stats&#39;, function (stats) {})</em></strong>",id:"engineonstats-function-stats-",level:4},{value:"<strong><em>engine.on(&#39;serverConnected&#39;, function (connected) {})</em></strong>",id:"engineonserverconnected-function-connected-",level:3},{value:"<strong><em>engine.on(&#39;exception&#39;, function (e) {})</em></strong>",id:"engineonexception-function-e-",level:3},{value:"Get p2p information from p2pConfig",id:"get-p2p-information-from-p2pconfig",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Dynamic MPD Path Support",id:"dynamic-mpd-path-support",level:3},{value:"Dynamic Segment Path Support",id:"dynamic-segment-path-support",level:3},{value:"Allow Http Range Request",id:"allow-http-range-request",level:3},{value:"How to Check Segment Validity",id:"how-to-check-segment-validity",level:3}],c={toc:d},m="wrapper";function y(e){var{components:n}=e,t=i(e,["components"]);return(0,r.yg)(m,o(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){a(e,n,t[n])})}return e}({},c,t),{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"create-instance"},"Create instance"),(0,r.yg)("h3",{id:"var-engine--new-p2penginedashplayer-p2pconfig-opts"},"var engine = new P2PEngineDash(player, {p2pConfig: ","[opts]","});"),(0,r.yg)("p",null,"Create a new ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"P2PEngineDash"))," instance, ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"player"))," is an instance of ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"dashjs#MediaPlayer"))," ."),(0,r.yg)("p",null,"If ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"opts"))," is specified, then the default options (shown below) will be overridden."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"center"},"Field"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Type"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Default"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"logLevel"),(0,r.yg)("td",{parentName:"tr",align:"center"},"string","|","boolean"),(0,r.yg)("td",{parentName:"tr",align:"center"},"'error'"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Print log level(warn, error, none, false=none, true=warn).")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"token"),(0,r.yg)("td",{parentName:"tr",align:"center"},"string"),(0,r.yg)("td",{parentName:"tr",align:"center"},"undefined"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Token is used to summarize and display multi domain name data on the console. In addition, token is required while customizing channelId.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"trackerZone"),(0,r.yg)("td",{parentName:"tr",align:"center"},"string"),(0,r.yg)("td",{parentName:"tr",align:"center"},"'eu'"),(0,r.yg)("td",{parentName:"tr",align:"center"},"The country code name of the tracker server address('eu', 'hk', 'us').")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"memoryCacheLimit"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Object"),(0,r.yg)("td",{parentName:"tr",align:"center"},'{"pc": 400 ',"*"," 1024 ","*",' 1024, "mobile": 100 ',"*"," 1024 ","*"," 1024}"),(0,r.yg)("td",{parentName:"tr",align:"center"},"The max size of binary data that can be stored in the cache.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"useDiskCache"),(0,r.yg)("td",{parentName:"tr",align:"center"},"boolean"),(0,r.yg)("td",{parentName:"tr",align:"center"},"true"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Use IndexedDB to cache data for VOD streaming.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"diskCacheLimit"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Object"),(0,r.yg)("td",{parentName:"tr",align:"center"},'{"pc": 1500 ',"*"," 1024 ","*",' 1024, "mobile": 1000 ',"*"," 1024 ","*"," 1024}"),(0,r.yg)("td",{parentName:"tr",align:"center"},"The max size of binary data that can be stored in the disk cache.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"p2pEnabled"),(0,r.yg)("td",{parentName:"tr",align:"center"},"boolean"),(0,r.yg)("td",{parentName:"tr",align:"center"},"true"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Enable or disable p2p engine.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"webRTCConfig"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Object"),(0,r.yg)("td",{parentName:"tr",align:"center"},"{}"),(0,r.yg)("td",{parentName:"tr",align:"center"},"A ",(0,r.yg)("a",{parentName:"td",href:"https://github.com/feross/simple-peer"},"Configuration dictionary")," providing options to configure WebRTC connections.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"useHttpRange"),(0,r.yg)("td",{parentName:"tr",align:"center"},"boolean"),(0,r.yg)("td",{parentName:"tr",align:"center"},"true"),(0,r.yg)("td",{parentName:"tr",align:"center"},"Use HTTP ranges requests where it is possible. Allows to continue (and not start over) aborted P2P downloads over HTTP.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"startFromSegmentOffset"),(0,r.yg)("td",{parentName:"tr",align:"center"},"number"),(0,r.yg)("td",{parentName:"tr",align:"center"},"3"),(0,r.yg)("td",{parentName:"tr",align:"center"},"The segment offset that start to connect to tracker server.")))),(0,r.yg)("h2",{id:"p2penginedash-api"},"P2PEngineDash API"),(0,r.yg)("h4",{id:"p2penginedashversion-static"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"P2PEngineDash.version"))," (static)"),(0,r.yg)("p",null,"Get the version of P2PEngineDash."),(0,r.yg)("h4",{id:"p2penginedashprotocolversion-static"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"P2PEngineDash.protocolVersion"))," (static)"),(0,r.yg)("p",null,"Get the version of P2P protocol."),(0,r.yg)("h4",{id:"p2penginedashissupported-static-method"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"P2PEngineDash.isSupported()"))," (static method)"),(0,r.yg)("p",null,"Returns true if WebRTC data channel is supported by the browser."),(0,r.yg)("h4",{id:"engineenablep2p"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.enableP2P()"))),(0,r.yg)("p",null,"Resume P2P if it has been stopped."),(0,r.yg)("h4",{id:"enginedisablep2p"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.disableP2P()"))),(0,r.yg)("p",null,"Disable engine to stop p2p and free used resources."),(0,r.yg)("h4",{id:"enginedestroy"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.destroy()"))),(0,r.yg)("p",null,"Stop p2p and free used resources."),(0,r.yg)("h2",{id:"p2penginedash-events"},"P2PEngineDash Events"),(0,r.yg)("h4",{id:"engineonpeerid-function-peerid-"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.on('peerId', function (peerId) {})"))),(0,r.yg)("p",null,"Emitted when the peer Id of this client is obtained from server."),(0,r.yg)("h4",{id:"engineonpeers-function-peers-"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.on('peers', function (peers) {})"))),(0,r.yg)("p",null,"Emitted when successfully connected with new peer."),(0,r.yg)("h4",{id:"engineonstats-function-stats-"},(0,r.yg)("strong",{parentName:"h4"},(0,r.yg)("em",{parentName:"strong"},"engine.on('stats', function (stats) {})"))),(0,r.yg)("p",null,"Emitted when data is downloaded/uploaded.",(0,r.yg)("br",null),"\nstats.totalHTTPDownloaded: total data downloaded by HTTP(KB).",(0,r.yg)("br",null),"\nstats.totalP2PDownloaded: total data downloaded by P2P(KB).",(0,r.yg)("br",null),"\nstats.totalP2PUploaded: total data uploaded by P2P(KB).",(0,r.yg)("br",null),"\nstats.p2pDownloadSpeed: p2p download speed(KB/s)."),(0,r.yg)("h3",{id:"engineonserverconnected-function-connected-"},(0,r.yg)("strong",{parentName:"h3"},(0,r.yg)("em",{parentName:"strong"},"engine.on('serverConnected', function (connected) {})"))),(0,r.yg)("p",null,"Emitted when websocket is opened/closed."),(0,r.yg)("h3",{id:"engineonexception-function-e-"},(0,r.yg)("strong",{parentName:"h3"},(0,r.yg)("em",{parentName:"strong"},"engine.on('exception', function (e) {})"))),(0,r.yg)("p",null,"Emitted when exception occured.",(0,r.yg)("br",null),"\ne.code: Exception identifier\uff08TRACKER_EXPT SIGNAL_EXPT DASHJS_EXPT\uff09",(0,r.yg)("br",null),"\ne.message: Exception message ",(0,r.yg)("br",null),"\ne.stack: Exception stack ",(0,r.yg)("br",null)),(0,r.yg)("h3",{id:"get-p2p-information-from-p2pconfig"},"Get p2p information from p2pConfig"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"p2pConfig: {\n    getStats: function (totalP2PDownloaded, totalP2PUploaded, totalHTTPDownloaded, p2pDownloadSpeed) {\n        // get the downloading statistics\n    },\n    getPeerId: function (peerId) {\n        // get peer Id\n    },\n    getPeersInfo: function (peers) {\n        // get peers information\n    },\n    onHttpDownloaded: function (traffic) {\n        // listen to http downloaded traffic\n    },\n    onP2pDownloaded: function (traffic, speed) {\n        // listen to p2p downloaded traffic\n    },\n    onP2pUploaded: function (traffic) {\n        // listen to p2p uploaded traffic\n    },\n}\n")),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"The unit of download and upload is KB.\nThe unit of download speed is KB/s.")),(0,r.yg)("h2",{id:"advanced-usage"},"Advanced Usage"),(0,r.yg)("h3",{id:"dynamic-mpd-path-support"},"Dynamic MPD Path Support"),(0,r.yg)("p",null,"Some MPD urls play the same live/vod but have different paths on them. For example,\nexample.com/clientId1/streamId.mpd and example.com/clientId2/streamId.mpd. In this case, you can format a common channelId for them."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"// Set token in p2pConfig before setting channelId!\np2pConfig: {\n    token: YOUR_TOKEN,\n    channelId: function (mpdUrl) {\n        const videoId = extractVideoIdFromUrl(mpdUrl);   // make a channelId by removing the different part which is defined by yourself\n        return videoId;\n    },\n    // channelId: VIDEO_ID       // for fixed channel id\n}\n")),(0,r.yg)("h3",{id:"dynamic-segment-path-support"},"Dynamic Segment Path Support"),(0,r.yg)("p",null,"Like dynamic mpd path, you should format a common segmentId for the same segment file. You can override the segment ID like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"p2pConfig: {\n    /*\n        streamId: The id of stream\n        sn: The serial number of segment\n        segmentUrl: The url of segment\n        range: bytes range of segmentUrl\n     */\n    segmentId: function (segmentUrl, range) {\n        const segId = extractSegmentIdFromUrl(segmentUrl);\n        return segId;\n    }\n}\n")),(0,r.yg)("h3",{id:"allow-http-range-request"},"Allow Http Range Request"),(0,r.yg)("p",null,"If http range request is activated, we are able to get chunks of data from peer and then complete the segments by getting other chunks from the CDN, thus, reducing your CDN bandwidth. Besides, the code below is needed\uff1a"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"p2pConfig: {\n    useHttpRange: true,\n}\n")),(0,r.yg)("h3",{id:"how-to-check-segment-validity"},"How to Check Segment Validity"),(0,r.yg)("p",null,"Sometimes we need to prevent a peer from sending a fake segment\n(such as the bittorrent with a hash function).\nCDNBye provides a validation callback with buffer of the\ndownloaded segment, developer should implement the actual\nvalidator. For example, you can create a program that generates\nhashes for the segments and stores them in a specific file or\ninjects into m3u8 playlist files the hashes information. If\nthe callback returns false, then the segment is not valid."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"p2pConfig: {\n   validateSegment: function (segId, buffer) {\n       var hash = hashFile.getHash(segId);\n       return hash === md5(buffer);\n   }\n}\n")))}y.isMDXComponent=!0},5680:(e,n,t)=>{t.d(n,{xA:()=>l,yg:()=>y});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach(function(n){a(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var g=r.createContext({}),p=function(e){var n=r.useContext(g),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=p(e.components);return r.createElement(g.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef(function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,g=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=a,y=d["".concat(g,".").concat(m)]||d[m]||c[m]||o;return t?r.createElement(y,i(i({ref:n},l),{},{components:t})):r.createElement(y,i({ref:n},l))});function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var g in n)hasOwnProperty.call(n,g)&&(s[g]=n[g]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);