"use strict";(self.webpackChunkswarmcloud_docs=self.webpackChunkswarmcloud_docs||[]).push([[8662],{2379:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>b,frontMatter:()=>p,metadata:()=>m,toc:()=>d});a(6540);var n=a(5680),r=a(4235),l=a(8328);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),a.push.apply(a,n)}return a}(Object(t)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}),e}function g(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}const p={title:"API & Config",sidebar_position:3},s=void 0,m={unversionedId:"API",id:"API",title:"API & Config",description:"P2P Configuration",source:"@site/docs/ios/API.mdx",sourceDirName:".",slug:"/API",permalink:"/home/ios/API",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"API & Config",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Usage",permalink:"/home/ios/"}},c={},d=[{value:"P2P Configuration",id:"p2p-configuration",level:2},{value:"P2pEngine",id:"p2pengine",level:2},{value:"Switch Stream URL",id:"switch-stream-url",level:2},{value:"Stop P2P",id:"stop-p2p",level:2},{value:"Disable P2P at runtime",id:"disable-p2p-at-runtime",level:2},{value:"Enable P2P at runtime",id:"enable-p2p-at-runtime",level:2},{value:"Stop P2P and Local Proxy",id:"stop-p2p-and-local-proxy",level:2},{value:"Restart Local Proxy",id:"restart-local-proxy",level:2},{value:"P2P Statistics",id:"p2p-statistics",level:2},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Callback Player Stats",id:"callback-player-stats",level:3},{value:"Dynamic M3u8 Path Support",id:"dynamic-m3u8-path-support",level:3},{value:"Setup HTTP headers",id:"setup-http-headers",level:3},{value:"Work in AirPlay mode",id:"work-in-airplay-mode",level:3},{value:"Support additional media file type of HLS",id:"support-additional-media-file-type-of-hls",level:3},{value:"Bypass User-specific Segments",id:"bypass-user-specific-segments",level:3},{value:"Intercept playlist",id:"intercept-playlist",level:3},{value:"Report Player Rebuffering",id:"report-player-rebuffering",level:3}],y={toc:d},u="wrapper";function b(e){var{components:t}=e,a=g(e,["components"]);return(0,n.yg)(u,o(function(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{},n=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(a).filter(function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable}))),n.forEach(function(t){i(e,t,a[t])})}return e}({},y,a),{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h2",{id:"p2p-configuration"},"P2P Configuration"),(0,n.yg)("p",null,"Create ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"P2pConfig"))," instance."),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"let config = P2pConfig()\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"P2pConfig* config = [P2pConfig defaultConfiguration];\n")))),(0,n.yg)("p",null,"The default fields (shown below) can be overridden."),(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:"center"},"Field"),(0,n.yg)("th",{parentName:"tr",align:"center"},"Type"),(0,n.yg)("th",{parentName:"tr",align:"center"},"Default"),(0,n.yg)("th",{parentName:"tr",align:"center"},"Description"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"trackerZone"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"TrackerZone"),(0,n.yg)("td",{parentName:"tr",align:"center"},".Europe"),(0,n.yg)("td",{parentName:"tr",align:"center"},"The country enum for the tracker server address(Europe, HongKong, USA)")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"debug"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"Bool"),(0,n.yg)("td",{parentName:"tr",align:"center"},"false"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Enable or disable log")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"logLevel"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"LogLevel"),(0,n.yg)("td",{parentName:"tr",align:"center"},".WARN"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Print log level(VERBOSE, DEBUG, INFO, WARN, ERROR)")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"iceServers"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"[IceServer]"),(0,n.yg)("td",{parentName:"tr",align:"center"},'[IceServer(url: "stun:stun.l.google.com:19302"), IceServer(url: "stun:global.stun.twilio.com:3478?transport=udp")]'),(0,n.yg)("td",{parentName:"tr",align:"center"},"For WebRTC Stun Configuration")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"announce"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"String?"),(0,n.yg)("td",{parentName:"tr",align:"center"},"nil"),(0,n.yg)("td",{parentName:"tr",align:"center"},"The address of tracker server")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"diskCacheLimit"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"UInt"),(0,n.yg)("td",{parentName:"tr",align:"center"},"2000 ","*"," 1024 ","*"," 1024"),(0,n.yg)("td",{parentName:"tr",align:"center"},"The max size of binary data that can be stored in the cache for VOD(Set to 0 will disable disk cache)")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"memoryCacheCountLimit"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"UInt"),(0,n.yg)("td",{parentName:"tr",align:"center"},"20"),(0,n.yg)("td",{parentName:"tr",align:"center"},"The max count of ts files that can be stored in the memory cache")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"p2pEnabled"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"Bool"),(0,n.yg)("td",{parentName:"tr",align:"center"},"true"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Enable or disable p2p engine")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"localPortHls"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"UInt"),(0,n.yg)("td",{parentName:"tr",align:"center"},"0"),(0,n.yg)("td",{parentName:"tr",align:"center"},"The port for local http server of HLS(Use random port by default)")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"customLabel"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"String?"),(0,n.yg)("td",{parentName:"tr",align:"center"},"${platform}-${system_version}"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Add a custom label to every different user session, which in turn will provide you the ability to have more meaningful analysis of the data gathered")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"maxPeerConnections"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"Int"),(0,n.yg)("td",{parentName:"tr",align:"center"},"25"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Max peer connections at the same time")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"startFromSegmentOffset"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"UInt"),(0,n.yg)("td",{parentName:"tr",align:"center"},"3"),(0,n.yg)("td",{parentName:"tr",align:"center"},"The segment offset that start to connect to tracker server")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"useHttpRange"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"Bool"),(0,n.yg)("td",{parentName:"tr",align:"center"},"true"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Use HTTP ranges requests where it is possible. Allows to continue (and not start over) aborted P2P downloads over HTTP")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"useStrictHlsSegmentId"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"Bool"),(0,n.yg)("td",{parentName:"tr",align:"center"},"false"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Use segment url based segment id instead of sequence number based one")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"httpHeadersHls"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"[String : String]","?"),(0,n.yg)("td",{parentName:"tr",align:"center"},"nil"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Set HTTP Headers while requesting ts and m3u8")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"sharePlaylist"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"Bool"),(0,n.yg)("td",{parentName:"tr",align:"center"},"false"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Allow the P2P transmission of m3u8 file")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"prefetchOnly"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"Bool"),(0,n.yg)("td",{parentName:"tr",align:"center"},"false"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Only use prefetch strategy in p2p downloading")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:"center"},(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"logPersistent"))),(0,n.yg)("td",{parentName:"tr",align:"center"},"Bool"),(0,n.yg)("td",{parentName:"tr",align:"center"},"false"),(0,n.yg)("td",{parentName:"tr",align:"center"},"Save logs to the file, default path is ",(0,n.yg)("strong",{parentName:"td"},(0,n.yg)("em",{parentName:"strong"},"Library/Caches/p2pengine.log")))))),(0,n.yg)("h2",{id:"p2pengine"},"P2pEngine"),(0,n.yg)("p",null,"Initialize ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"P2pEngine"))," in ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"AppDelegate.m")),":"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\nP2pEngine.setup(token: YOUR_TOKEN)\nreturn true\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n  [P2pEngine setupWithToken:YOUR_TOKEN config:NULL];\n  return YES;\n}\n")))),(0,n.yg)("p",null,"Where ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"token"))," is your Customer ID, please replace it by your own token obtained from console."),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"let parsedUrl = P2pEngine.shared.parseStreamUrl(ORIGINAL_URL)\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"NSString *parsedUrl = [[P2pEngine sharedInstance] parseStreamUrl:ORIGINAL_URL];\n")))),(0,n.yg)("h2",{id:"switch-stream-url"},"Switch Stream URL"),(0,n.yg)("p",null,"When Switching to a new stream URL, before passing new stream url(m3u8) to the player, pass that URL through ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"P2pEngine"))," instance:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"let newParsedURL = P2pEngine.shared.parseStreamUrl(NEW_ORIGINAL_URL)\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"NSString *newParsedURL = [[P2pEngine sharedInstance] parseStreamUrl:NEW_ORIGINAL_URL];\n")))),(0,n.yg)("h2",{id:"stop-p2p"},"Stop P2P"),(0,n.yg)("p",null,"Stop p2p streaming of current source, but keep local proxy working:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"override func viewDidDisappear(_ animated: Bool) {\nP2pEngine.shared.stopP2p()\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"- (void)viewDidDisappear:(BOOL)animated {\n[P2pEngine.sharedInstance stopP2p];\n}\n")))),(0,n.yg)("h2",{id:"disable-p2p-at-runtime"},"Disable P2P at runtime"),(0,n.yg)("p",null,"it will not take effect until the next media file is played."),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"P2pEngine.shared.disableP2p()\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"[P2pEngine.sharedInstance disableP2p];\n")))),(0,n.yg)("h2",{id:"enable-p2p-at-runtime"},"Enable P2P at runtime"),(0,n.yg)("p",null,"it will not take effect until the next media file is played."),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"P2pEngine.shared.enableP2p()\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"[P2pEngine.sharedInstance enableP2p];\n")))),(0,n.yg)("h2",{id:"stop-p2p-and-local-proxy"},"Stop P2P and Local Proxy"),(0,n.yg)("p",null,"Stop p2p streaming of current source and local proxy:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"P2pEngine.shared.shutdown()\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"[P2pEngine.sharedInstance shutdown];\n")))),(0,n.yg)("h2",{id:"restart-local-proxy"},"Restart Local Proxy"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"P2pEngine.shared.startLocalServer()\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"[P2pEngine.sharedInstance startLocalServer];\n")))),(0,n.yg)("h2",{id:"p2p-statistics"},"P2P Statistics"),(0,n.yg)("p",null,"Use ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"P2pStatisticsMonitor"))," to observe downloading statistics:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"let monitor = P2pStatisticsMonitor(queue: .main)\nP2pEngine.shared.p2pStatisticsMonitor = monitor\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"P2pStatisticsMonitor* monitor = [[P2pStatisticsMonitor alloc] initWithQueue:dispatch_get_main_queue()];\nP2pEngine.shared.p2pStatisticsMonitor = monitor;\n")))),(0,n.yg)("p",null,"Then get the downloading statistics, including ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"p2pDownloaded")),"\u3001",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"p2pUploaded")),"\u3001",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"httpDownloaded")),"\u3001",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"peers")),"\u3001",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"serverConnected"))),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"monitor.onPeers = { peers in\n}\nmonitor.onP2pUploaded = { value in\n}\nmonitor.onP2pDownloaded = { value, speed in\n}\nmonitor.onHttpDownloaded = { value in\n}\nmonitor.onServerConnected = { connected in\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"monitor.onPeers = ^(NSArray<NSString *> * _Nonnull peers) {\n};\nmonitor.onP2pUploaded = ^(NSInteger value) {\n};\nmonitor.onP2pDownloaded = ^(NSInteger value, NSInteger speed) {\n};\nmonitor.onHttpDownloaded = ^(NSInteger value) {\n};\nmonitor.onServerConnected = ^(BOOL connected) {\n};\n")))),(0,n.yg)("admonition",{type:"note"},(0,n.yg)("p",{parentName:"admonition"},"The unit of download and upload is KB.")),(0,n.yg)("h2",{id:"advanced-usage"},"Advanced Usage"),(0,n.yg)("h3",{id:"callback-player-stats"},"Callback Player Stats"),(0,n.yg)("p",null,"On Live streaming, to improve performance, we recommend to tell p2p engine the duration from the playback time to the end of the buffered interval.\nIn order to do so, you need to implement ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"PlayerInteractor"))," ."),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"class ViewController: UIViewController {\n...\n  P2pEngine.shared.playerInteractor = self\n...\n}\nextension ViewController : PlayerInteractor {\nfunc onBufferedDuration() -> TimeInterval {\nlet currentTime = CMTimeGetSeconds(self.avplayer.currentTime())\nvar bufferedDuration: Double = 0.0\nlet timeRanges = self.avplayer.currentItem!.loadedTimeRanges\nfor value in timeRanges {\nlet timeRange = value.timeRangeValue\nlet start = CMTimeGetSeconds(timeRange.start)\nlet end = start + CMTimeGetSeconds(timeRange.duration);\nif (currentTime >= start && currentTime <= end) {\nbufferedDuration = end - currentTime;\nbreak;\n}\n}\nreturn bufferedDuration;\n}\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"@interface ViewController () <PlayerInteractor>\n...\nP2pEngine.shared.playerInteractor = self;\n...\n#pragma mark - **************** PlayerInteractor ****************\n-(NSTimeInterval)onBufferedDuration {\nNSTimeInterval currentTime = CMTimeGetSeconds([self.player currentTime]);\nNSTimeInterval bufferedDuration = 0;\nfor (NSValue *value in [[self.player currentItem] loadedTimeRanges]) {\nCMTimeRange timeRange = [value CMTimeRangeValue];\nNSTimeInterval start = CMTimeGetSeconds(timeRange.start);\nNSTimeInterval end = start + CMTimeGetSeconds(timeRange.duration);\nif (currentTime >= start && currentTime <= end) {\nbufferedDuration = end - currentTime;\nbreak;\n}\n}\nreturn bufferedDuration;\n}\n")))),(0,n.yg)("p",null,"On the VOD mode, the duration of a video may be large. If we can match peers with similar playback time, it will help to improve the P2P performance, so we recommend to tell p2p engine the current playback time of player:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"class ViewController: UIViewController {\n...\n  P2pEngine.shared.playerInteractor = self\n...\n}\nextension ViewController : PlayerInteractor {\nfunc onCurrentPosition() -> TimeInterval {\nreturn CMTimeGetSeconds(self.avplayer.currentTime())\n}\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"@interface ViewController () <PlayerInteractor>\n...\nP2pEngine.shared.playerInteractor = self;\n...\n- (NSTimeInterval)onCurrentPosition {\nreturn CMTimeGetSeconds([self.player currentTime]);\n}\n")))),(0,n.yg)("h3",{id:"dynamic-m3u8-path-support"},"Dynamic M3u8 Path Support"),(0,n.yg)("p",null,"The channelId is an identifier used by our backend to match peers that are watching the same content. It is an optional parameter, and by default, we generate channelId from the content URL by removing any query parameters and protocol from it.\nSome m3u8 urls play the same live/vod but have different paths on them. For example, example.com/clientId1/streamId.m3u8 and example.com/clientId2/streamId.m3u8. In this case, you can format a common channelId for them."),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"let videoId = extractVideoIdFromUrl(url: orginalUrl)                      // extractVideoIdFromUrl \u9700\u8981\u81ea\u5df1\u5b9a\u4e49, \u53ef\u4ee5\u62bd\u53d6url\u4e2d\u7684\u89c6\u9891ID\u4f5c\u4e3a\u7ed3\u679c\u8fd4\u56de\nlet parsedUrl = P2pEngine.shared.parseStreamUrl(orginalUrl, videoId: videoId)\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"NSString *videoId = [Utils extractVideoIdFromUrl:originalUrl];            // extractVideoIdFromUrl \u9700\u8981\u81ea\u5df1\u5b9a\u4e49, \u53ef\u4ee5\u62bd\u53d6url\u4e2d\u7684\u89c6\u9891ID\u4f5c\u4e3a\u7ed3\u679c\u8fd4\u56de\nNSURL *parsedUrl = [[P2pEngine sharedInstance] parseStreamUrl:originalUrl videoId:videoId];\n")))),(0,n.yg)("h3",{id:"setup-http-headers"},"Setup HTTP headers"),(0,n.yg)("p",null,"Some HTTP requests need to add header information such as ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"User-Agent"))," for Anti-Leech or statistical requirements. It can be set via ",(0,n.yg)("strong",{parentName:"p"},(0,n.yg)("em",{parentName:"strong"},"httpHeaders"))," :"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},'p2pConfig.httpHeadersHls = ["User-Agent": "XXX"]\n'))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},'p2pConfig.httpHeadersHls = @{@"User-Agent": @"XXX"};\n')))),(0,n.yg)("p",null,"Or set HTTP headers dynamically:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},'P2pEngine.shared.setHttpHeadersForHls(headers: ["User-Agent": "XXX"])\n'))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},'[P2pEngine.shared setHttpHeadersForHlsWithHeaders: @{@"User-Agent": @"XXX"}];\n')))),(0,n.yg)("h3",{id:"work-in-airplay-mode"},"Work in AirPlay mode"),(0,n.yg)("p",null,"SwarmCloud does not directly support AirPlay mode at the moment but it is easy to make it work in an app. The way to do this is to only use the Proxy URL when the app is not airplaying:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"if (/* player is in AirPlay mode */) {\n    // set URL to original version\n   [player replaceCurrentItemWithPlayerItem:[AVPlayerItem playerItemWithURL:original]];\n} else {\n    // airplay stopped - set URL to result of parseStreamURL\n   [player replaceCurrentItemWithPlayerItem:[AVPlayerItem playerItemWithURL:rewritten]];\n}\n")),(0,n.yg)("h3",{id:"support-additional-media-file-type-of-hls"},"Support additional media file type of HLS"),(0,n.yg)("p",null,'By default, only common file types with suffix such as ".ts" are supported. If you need to support file types similar to ".image", you need to make the following configuration:'),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},'let config = P2pConfig()\nconfig.hlsMediaFiles = ["ts", "image"]\nP2pEngine.shared.setup(token: YOUR_TOKEN, config: config)\n'))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},'P2pConfig *config = [P2pConfig defaultConfiguration];\nconfig.hlsMediaFiles = @[@"ts", @"image"];\n[[P2pEngine sharedInstance] setupWithToken:YOUR_TOKEN config:config];\n')))),(0,n.yg)("p",null,'Generally, HLS media files end with ".xx", but there are exceptions. In order for the local proxy to recognize these extensions, the following configuration is required:'),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"class ViewController: UIViewController {\n...\n  P2pEngine.shared.hlsInterceptor = self\n...\n}\nextension ViewController : HlsInterceptor {\nfunc isMediaSegment(url: String) -> Bool {\nreturn mediaFileRegex.match(url)\n}\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"@interface ViewController () <HlsInterceptor>\n...\nP2pEngine.shared.hlsInterceptor = self;\n...\n#pragma mark - **************** HlsInterceptor ****************\n- (BOOL)isMediaSegmentWithUrl:(NSString *)url {\nreturn [mediaFileRegex match:url];\n}\n")))),(0,n.yg)("h3",{id:"bypass-user-specific-segments"},"Bypass User-specific Segments"),(0,n.yg)("p",null,"Sometimes we don't want some ts files to be shared, such as user-specific ts generated by SSAI (Server Side Ad Insertion). At this time, we can use the segmentBypass function to bypass it:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"class ViewController: UIViewController {\n...\n  P2pEngine.shared.hlsInterceptor = self\n...\n}\nextension ViewController : HlsInterceptor {\nfunc shouldBypassSegment(url: String) -> Bool {\nreturn isSSAISegment(url)\n}\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"@interface ViewController () <HlsInterceptor>\n...\nP2pEngine.shared.hlsInterceptor = self;\n...\n#pragma mark - **************** HlsInterceptor ****************\n- (BOOL)shouldBypassSegment:(NSString *)url {\nreturn [Utils isSSAISegment:url];\n}\n")))),(0,n.yg)("h3",{id:"intercept-playlist"},"Intercept playlist"),(0,n.yg)("p",null,"The SDK will parse the contents of m3u8 when downloaded, if you use encrypted m3u8, you need to use the interceptor to intercept and return the standard m3u8 file:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"class ViewController: UIViewController {\n...\n  P2pEngine.shared.hlsInterceptor = self\n...\n}\nextension ViewController : HlsInterceptor {\nfunc interceptPlaylist(data: Data, url: String) -> Data {\nreturn handlePlaylist(data, url)\n}\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"@interface ViewController () <HlsInterceptor>\n...\nP2pEngine.shared.hlsInterceptor = self;\n...\n#pragma mark - **************** HlsInterceptor ****************\n- (NSData *)interceptPlaylistWithData:(NSData *)data url:(NSString *)url {\nreturn [Utils handlePlaylistWithData:data url:url];\n}\n")))),(0,n.yg)("h3",{id:"report-player-rebuffering"},"Report Player Rebuffering"),(0,n.yg)("p",null,"You may want to report the player rebuffering event to the sdk, then get average rebuffer ratio from SwarmCloud dashboard:"),(0,n.yg)(r.A,{groupId:"ios",mdxType:"Tabs"},(0,n.yg)(l.A,{value:"swift",label:"swift",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-swift"},"NotificationCenter.default.addObserver(self, selector: #selector(handleItemPlayBackStall), name: NSNotification.Name.AVPlayerItemPlaybackStalled, object: player.currentItem)\n\n@objc func handleItemPlayBackStall() {\nP2pEngine.shared.notifyPlaybackStalled()\n}\n"))),(0,n.yg)(l.A,{value:"objectivec",label:"objective-c",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-objectivec"},"[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(handleItemPlayBackStall) name:AVPlayerItemPlaybackStalledNotification object:self.playerVC.player.currentItem];\n\n- (void)handleItemPlayBackStall {\n[P2pEngine.sharedInstance notifyPlaybackStalled];\n}\n")))))}b.isMDXComponent=!0}}]);